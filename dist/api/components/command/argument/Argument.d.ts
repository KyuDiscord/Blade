import type { TypeResolver } from "./TypeResolver";
import type { Command } from "../Command";
import type { Content } from "../Context";
import type { ArgumentMatch, ArgumentOptions, ArgumentPromptOptions, ArgumentType, ArgumentTypeCaster, FailureData, Modifier, ParsedValuePredicate, Supplier } from "./Types";
import type { BladeClient } from "../../../Client";
import { CommandStore } from "../../../..";
import { Flag } from "./Flag";
import type { Message } from "eris";
export declare class Argument {
    command: Command;
    match: ArgumentMatch;
    type: ArgumentType | ArgumentTypeCaster;
    flag?: string | string[];
    multipleFlags: boolean;
    index?: number;
    unordered: boolean | number | number[];
    limit: number;
    prompt?: ArgumentPromptOptions;
    default: any | Supplier<FailureData, any>;
    otherwise?: Content | Supplier<FailureData, Content>;
    modifyOtherwise: Modifier<FailureData, Content>;
    constructor(command: Command, { match, type, flag, multipleFlags, index, unordered, limit, prompt, default: defaultValue, otherwise, modifyOtherwise, }?: ArgumentOptions);
    get client(): BladeClient;
    get handler(): CommandStore;
    static cast(type: ArgumentType | ArgumentTypeCaster, resolver: TypeResolver, message: Message, phrase: string): Promise<any>;
    static union(...types: (ArgumentType | ArgumentTypeCaster)[]): ArgumentTypeCaster;
    static product(...types: (ArgumentType | ArgumentTypeCaster)[]): ArgumentTypeCaster;
    static validate(type: ArgumentType | ArgumentTypeCaster, predicate: ParsedValuePredicate): ArgumentTypeCaster;
    static range(type: ArgumentType | ArgumentTypeCaster, min: number, max: number, inclusive?: boolean): ArgumentTypeCaster;
    static compose(...types: (ArgumentType | ArgumentTypeCaster)[]): ArgumentTypeCaster;
    static composeWithFailure(...types: (ArgumentType | ArgumentTypeCaster)[]): ArgumentTypeCaster;
    static withInput(type: ArgumentType | ArgumentTypeCaster): ArgumentTypeCaster;
    static tagged(type: ArgumentType | ArgumentTypeCaster, tag?: string | RegExp | ArgumentTypeCaster | (string | string[])[]): ArgumentTypeCaster;
    static taggedWithInput(type: ArgumentType | ArgumentTypeCaster, tag?: string | RegExp | ArgumentTypeCaster | (string | string[])[]): ArgumentTypeCaster;
    static taggedUnion(...types: (ArgumentType | ArgumentTypeCaster)[]): ArgumentTypeCaster;
    static isFailure(value: any): boolean;
    process(message: Message, phrase: string): Promise<Flag | any>;
    cast(message: Message, phrase: string): Promise<any>;
    collect(message: Message, commandInput?: string, parsedInput?: any): Promise<Flag | any>;
}
