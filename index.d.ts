// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//
//   ../@ayanaware/logger
//   ../events
//   ../@klasa/event-iterator
//   ../@ayanaware/errors

import type { GenericError } from "@ayanaware/errors";
import type { Logger } from "@ayanaware/logger";
import type { EventIterator, EventIteratorOptions } from "@klasa/event-iterator";
import type { Base, Client, ClientOptions, Collection as Col, EmbedOptions, Emoji, Guild, GuildChannel, Member, Message, MessageContent, OAuthApplicationInfo, Permission, PrivateChannel, Role, TextableChannel, TextChannel, User, VoiceChannel, MessageFile } from "eris";
import type { EventEmitter } from "events";

declare namespace Blade {
  export interface BladeOptions extends ClientOptions {
    directory?: string;
    token: string;
    owners?: string | string[];
    language?: LanguageHelperOptions;
  }
  /**
   * The base class for creating a bot.
   * @extends Client
   * @since 1.0.0
   */
  export class BladeClient extends Client {
    static basePermissions: (2048 | 1024)[];
    /**
     * This client's language helper.
     * @since 1.0.5
     */
    readonly languages: LanguageHelper;
    /**
     * This client's logger.
     * @since 1.0.4
     */
    readonly logger: Logger;
    /**
     * A utility class for resolving different classes like Emoji and Member.
     * @since 1.0.0
     */
    readonly util: ClientUtil;
    /**
     * Oauth2 Application Info.
     * @since 1.0.0
     */
    app?: OAuthApplicationInfo;
    /**
     * The base directory of the bot.
     * @since 1.0.0
     */
    directory: string;
    /**
     * Whether the client has been started or not.
     * @since 1.0.0
     */
    started: boolean;
    /**
     * A set of owners.
     */
    owners: Set<User>;
    /**
     * The options that were given to this client.
     */
    options: BladeOptions;
    /**
     * A set of stores that are being used by the client.
     * @since 1.0.0
     */
    readonly stores: Collection<string, Store<Part>>;
    /**
     * Creates a new BladeClient.
     * @param options
     */
    constructor(options: BladeOptions);
    get invite(): string | null;
    /**
     * Starts the bot.
     * @since 1.0.0
     */
    start(): Promise<this>;
    /**
     * Check if a member or user is an owner.
     * @param resolvable The member/user to check.
     * @since 1.0.0
     */
    isOwner(resolvable: User | Member): boolean;
  }

  export interface IStructures {
    context: typeof Context;
    replyBuilder: typeof ReplyBuilder;
  }
  export abstract class Structures {
    /**
     * Extend a part used by blade.
     * @since 1.0.6
     */
    static extend<K extends keyof IStructures, B extends IStructures[K]>(
      structure: K,
      extender: (base: IStructures[K]) => B | B
    ): typeof Structures;
    /**
     * Get a part.
     * @param part The part to get.
     * @since 1.0.6
     */
    static get<K extends keyof IStructures>(structure: K): IStructures[K];
  }

  export class Argument {
    command: Command;
    match: ArgumentMatch;
    type: ArgumentType | ArgumentTypeCaster;
    flag?: string | string[];
    multipleFlags: boolean;
    index?: number;
    unordered: boolean | number | number[];
    limit: number;
    prompt?: ArgumentPromptOptions;
    default: any | Supplier<FailureData, any>;
    otherwise?: Content | Supplier<FailureData, Content>;
    modifyOtherwise: Modifier<FailureData, Content>;
    constructor(
      command: Command,
      {
        match,
        type,
        flag,
        multipleFlags,
        index,
        unordered,
        limit,
        prompt,
        default: defaultValue,
        otherwise,
        modifyOtherwise,
      }?: ArgumentOptions
    );
    get client(): BladeClient;
    get handler(): CommandStore;
    static cast(
      type: ArgumentType | ArgumentTypeCaster,
      resolver: TypeResolver,
      message: Message,
      phrase: string
    ): Promise<any>;
    static union(
      ...types: (ArgumentType | ArgumentTypeCaster)[]
    ): ArgumentTypeCaster;
    static product(
      ...types: (ArgumentType | ArgumentTypeCaster)[]
    ): ArgumentTypeCaster;
    static validate(
      type: ArgumentType | ArgumentTypeCaster,
      predicate: ParsedValuePredicate
    ): ArgumentTypeCaster;
    static range(
      type: ArgumentType | ArgumentTypeCaster,
      min: number,
      max: number,
      inclusive?: boolean
    ): ArgumentTypeCaster;
    static compose(
      ...types: (ArgumentType | ArgumentTypeCaster)[]
    ): ArgumentTypeCaster;
    static composeWithFailure(
      ...types: (ArgumentType | ArgumentTypeCaster)[]
    ): ArgumentTypeCaster;
    static withInput(
      type: ArgumentType | ArgumentTypeCaster
    ): ArgumentTypeCaster;
    static tagged(
      type: ArgumentType | ArgumentTypeCaster,
      tag?: string | RegExp | (string | string[])[] | ArgumentTypeCaster
    ): ArgumentTypeCaster;
    static taggedWithInput(
      type: ArgumentType | ArgumentTypeCaster,
      tag?: string | RegExp | (string | string[])[] | ArgumentTypeCaster
    ): ArgumentTypeCaster;
    static taggedUnion(
      ...types: (ArgumentType | ArgumentTypeCaster)[]
    ): ArgumentTypeCaster;
    static isFailure(value: any): boolean;
    process(message: Message, phrase: string): Promise<Flag | any>;
    cast(message: Message, phrase: string): Promise<any>;
    collect(
      message: Message,
      commandInput?: string,
      parsedInput?: any
    ): Promise<Flag | any>;
  }

  export type ArgumentGenerator = (
    ctx: Context,
    parsed: ContentParserResult,
    state: ArgumentRunnerState
  ) => IterableIterator<ArgumentOptions | Flag>;
  export interface ArgumentRunnerState {
    usedIndices: Set<number>;
    phraseIndex: number;
    index: number;
  }
  export class ArgumentRunner {
    command: Command;
    constructor(command: Command);
    get client(): BladeClient;
    get handler(): CommandStore;
    run(
      message: Message,
      parsed: ContentParserResult,
      generator: ArgumentGenerator
    ): Promise<any>;
    runOne(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runPhrase(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<any>;
    runRest(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runSeparate(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runFlag(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runOption(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runText(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runContent(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runRestContent(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    runNone(
      message: Message,
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      arg: Argument
    ): Promise<Flag | any>;
    static increaseIndex(
      parsed: ContentParserResult,
      state: ArgumentRunnerState,
      n?: number
    ): void;
    static isShortCircuit(value: any): boolean;
    static fromArguments(args: [string, Argument][]): ArgumentGenerator;
  }

  export interface ContentParserOptions {
    flagWords?: string[];
    optionFlagWords?: string[];
    quoted?: boolean;
    separator?: string;
  }
  export interface StringData {
    type: "Phrase" | "Flag" | "OptionFlag";
    raw: string;
    key?: string;
    value?: string;
  }
  export interface ExtractedFlags {
    flagWords: string[];
    optionFlagWords: string[];
  }
  export interface ContentParserResult {
    all: StringData[];
    phrases: StringData[];
    flags: StringData[];
    optionFlags: StringData[];
  }
  export class ContentParser {
    flagWords: string[];
    optionFlagWords: string[];
    quoted: boolean;
    separator: string;
    constructor({
      flagWords,
      optionFlagWords,
      quoted,
      separator,
    }?: ContentParserOptions);
    static getFlags(args: ArgumentOptions[]): Record<string, string[]>;
    parse(content: string): ContentParserResult;
  }

  export class Flag {
    type: string;
    command?: string;
    ignore?: boolean;
    rest?: string;
    message?: Message;
    value?: any;
    constructor(type: string, data?: Record<string, any>);
    static cancel(): Flag;
    static retry(message: Message): Flag;
    static fail(value: any): Flag;
    static continue(command: string, ignore?: boolean, rest?: null): Flag;
    static is(value: any, type: string): boolean;
  }

  export class TypeResolver {
    handler: CommandStore;
    client: BladeClient;
    types: Collection<string, ArgumentTypeCaster>;
    commands: CommandStore;
    inhibitors: InhibitorStore | null;
    listeners: SubscriberStore | null;
    monitors: MonitorStore | null;
    constructor(handler: CommandStore);
    addBuiltInTypes(): void;
    type(name: string): ArgumentTypeCaster;
    addType(name: string, fn: ArgumentTypeCaster): TypeResolver;
    addTypes(types: Record<string, ArgumentTypeCaster>): TypeResolver;
  }

  export interface ArgumentOptions {
    id?: string;
    match?: ArgumentMatch;
    flag?: string | string[];
    type?: ArgumentType | ArgumentTypeCaster;
    multipleFlags?: boolean;
    index?: number;
    unordered?: boolean | number | number[];
    limit?: number;
    default?: any | Supplier<FailureData, any>;
    otherwise?: Content | Supplier<FailureData, Content>;
    modifyOtherwise?: Modifier<FailureData, Content>;
    prompt?: ArgumentPromptOptions;
  }
  export interface ArgumentPromptData {
    retries: number;
    infinite: boolean;
    message: Message;
    phrase: string;
    failure: void | Flag;
  }
  export interface ArgumentPromptOptions {
    retries?: number;
    time?: number;
    cancelWord?: string;
    optional?: boolean;
    infinite?: boolean;
    limit?: number;
    breakout?: boolean;
    start?: MessageContent | Supplier<ArgumentPromptData, Content>;
    retry?: MessageContent | Supplier<ArgumentPromptData, Content>;
    timeout?: MessageContent | Supplier<ArgumentPromptData, Content>;
    ended?: MessageContent | Supplier<ArgumentPromptData, Content>;
    cancel?: MessageContent | Supplier<ArgumentPromptData, Content>;
    stopWord?: string;
    modifyStart?: Modifier<ArgumentPromptData, Content>;
    modifyRetry?: Modifier<ArgumentPromptData, Content>;
    modifyTimeout?: Modifier<ArgumentPromptData, Content>;
    modifyEnded?: Modifier<ArgumentPromptData, Content>;
    modifyCancel?: Modifier<ArgumentPromptData, Content>;
  }
  export interface FailureData {
    phrase: string;
    failure: void | Flag;
  }
  export interface DefaultArgumentOptions {
    prompt?: ArgumentPromptOptions;
    otherwise?: Content | Supplier<FailureData, Content>;
    modifyOtherwise?: Modifier<FailureData, Content>;
  }
  export type ArgumentMatch =
    | "phrase"
    | "flag"
    | "option"
    | "rest"
    | "separate"
    | "text"
    | "content"
    | "restContent"
    | "none";
  export type ArgumentType =
    | "string"
    | "lowercase"
    | "uppercase"
    | "charCodes"
    | "number"
    | "integer"
    | "bigint"
    | "emojint"
    | "url"
    | "date"
    | "color"
    | "user"
    | "users"
    | "member"
    | "members"
    | "relevant"
    | "relevants"
    | "channel"
    | "channels"
    | "textChannel"
    | "textChannels"
    | "voiceChannel"
    | "voiceChannels"
    | "categoryChannel"
    | "categoryChannels"
    | "newsChannel"
    | "newsChannels"
    | "storeChannel"
    | "storeChannels"
    | "role"
    | "roles"
    | "emoji"
    | "emojis"
    | "guild"
    | "guilds"
    | "message"
    | "guildMessage"
    | "relevantMessage"
    | "invite"
    | "userMention"
    | "memberMention"
    | "channelMention"
    | "roleMention"
    | "emojiMention"
    | "commandAlias"
    | "command"
    | "inhibitor"
    | "listener"
    | (string | string[])[]
    | RegExp
    | string;
  export type Modifier<D, T> = (
    ctx?: Context,
    text?: Content,
    data?: D
  ) => T | Promise<T>;
  export type Supplier<D, T> = (message: Message, data?: D) => T | Promise<T>;
  export type ArgumentTypeCaster = (message: Message, value?: any) => any;
  export type ParsedValuePredicate = (
    message?: Message,
    phrase?: string,
    value?: any
  ) => boolean;

  export type Content =
    | MessageContent
    | EmbedBuilder
    | ((
        builder: ReplyBuilder,
        ctx: Context
      ) => ReplyBuilder | Promise<ReplyBuilder>);
  export interface ContextData {
    afterPrefix?: string;
    alias?: string;
    command?: Command;
    content?: string;
    prefix?: string;
  }
  export class Context {
    readonly store: CommandStore;
    readonly client: BladeClient;
    readonly message: Message;
    /** Stuff */
    command?: Command;
    parsed?: ContextData;
    /** Command Editing Stuff. */
    shouldEdit: boolean;
    lastResponse?: Message;
    messages: Map<string, Message> | null;
    constructor(store: CommandStore, message: Message);
    /**
     * Returns the guild in which this message was sent in.
     * @since 1.0.0
     */
    get guild(): Guild | undefined;
    /**
     * Returns the author of the message.
     * @since 1.0.0
     */
    get author(): User;
    /**
     * Returns the member who sent the message if any.
     * @since 1.0.0
     */
    get member(): Member | undefined;
    /**
     * Returns the channel this message was sent in.
     * @since 1.0.0
     */
    get channel(): TextableChannel;
    /**
     * Returns the client as a guild member.
     * @since 1.0.0
     */
    get me(): Member;
    /**
     * Transforms any reply builders.
     * @since 1.0.0
     */
    static getTransformed(
      context: Context,
      message: Content
    ): Promise<MessageContent>;
    /**
     * Sends a response or edits an old response if available.
     * @param content The content of the response.
     * @since 1.0.0
     */
    reply(content: Content): Promise<Message>;
    /**
     * Sends a response, overwriting the last response.
     * @param content The content to send.
     * @since 1.0.0
     */
    sendNew(content: Content): Promise<Message>;
    /**
     * Edits the last response.
     * @param content Edit content.
     * @since 1.0.0
     */
    edit(content: Content): Promise<Message>;
    /**
     * Adds client prompt or user reply to messages.
     * @param message Message(s) to add.
     */
    addMessage(message: Message | Message[]): Message | Message[];
    /**
     * Sets the last response.
     * @param message Response to set.
     * @since 1.0.0
     */
    setLastResponse(message: Message | Message[]): Message;
    /**
     * Changes if the message should be edited.
     * @param state Whether the message should be editable or not.
     * @since 1.0.0
     */
    setEditable(state: boolean): this;
    /**
     * Get a translation string.
     * @param path The translation to get.
     * @param data
     * @since 1.0.5
     */
    t<T = string>(path: string, data?: Record<string, any>): T;
  }

  export class ReplyBuilder {
    readonly ctx: Context;
    constructor(ctx: Context);
    content(str: string): ReplyBuilder;
    tts(value: boolean): ReplyBuilder;
    file(file: MessageFile): ReplyBuilder;
    embed(
      embed:
        | EmbedOptions
        | EmbedBuilder
        | ((builder: EmbedBuilder, ctx: Context) => EmbedBuilder)
    ): ReplyBuilder;
    display(tc: TextableChannel): Promise<Message>;
    build(): [MessageContent, MessageFile[]];
  }

  export type LoadFilter = (file: string) => boolean | Promise<boolean>;
  export type ComponentResolvable<T> = string | T;
  export interface StoreOptions {
    classToHandle?: typeof Part;
    priority?: number;
    loadFilter?: LoadFilter;
    autoCategory?: boolean;
    defaults?: PartOptions;
    createDirectory?: boolean;
    directory?: string;
  }
  /**
   * A part store.
   * @since 1.0.0
   */
  export abstract class Store<T extends Part> extends LiteEmitter {
    /**
     * The client that is using this store.
     * @since 1.0.0
     */
    readonly client: BladeClient;
    /**
     * All of the loaded parts.
     * @since 1.0.0
     */
    readonly parts: Collection<string, T>;
    /**
     * The name of this store.
     * @since 1.0.0
     */
    name: string;
    /**
     * The priority this store has when being loaded.
     * @since 1.0.0
     */
    priority: number;
    /**
     * The class this store handles / loads.
     * @since 1.0.0
     */
    classToHandle: typeof Part;
    /**
     * The load filter for this store.
     * @since 1.0.0
     */
    loadFilter: LoadFilter;
    /**
     * Whether to create the directory if none exists.
     * @since 1.0.0
     */
    createDirectory: boolean;
    /**
     * The directory to load from.
     * @since 1.0.0
     */
    directory: string;
    /**
     * Creates a new Component Store.
     * @param client The client that's using this store.
     * @param name The name of this store.
     * @param options The options to give this store.
     * @since 1.0.0
     */
    protected constructor(
      client: BladeClient,
      name: string,
      options?: StoreOptions
    );
    static walkDir(store: Store<Part>, dir: string): Promise<Part>[];
    load(directory: string, file: string[]): Promise<T>;
    /**
     * Loads all files in the given directory.
     * @since 1.0.0
     * @returns {number} Total parts loaded.
     */
    loadAll(): Promise<number>;
    /**
     * Resolves a string or part into... a part.
     * @param resolvable
     * @returns {Part} The resolved part.
     */
    resolve(resolvable: ComponentResolvable<T>): T | undefined;
    /**
     * Removes a part from the store.
     * @param resolvable The part to remove.
     * @since 1.0.0
     */
    remove(resolvable: ComponentResolvable<T>): T | null;
    /**
     * Adds a part to the store.
     * @param part
     * @since 1.0.0
     */
    add(part: T): T | null;
    /**
     * Returns the string representation of this store.
     * @since 1.0.0
     */
    toString(): string;
  }

  export interface PartOptions {
    name?: string;
    disabled?: boolean;
    category?: string;
  }
  /**
   * An abstracted base class for all parts like Command and Subscriber.
   * @since 1.0.0
   * @abstract
   */
  export abstract class Part {
    /**
     * This parts logger.
     * @since 1.0.4
     */
    readonly logger: Logger;
    /**
     * The blade client.
     * @since 1.0.0
     */
    readonly client: BladeClient;
    /**
     * THe store this part belongs to
     * @since 1.0.0
     */
    readonly store: Store<Part>;
    /**
     * The file array of this part.
     * @since 1.0.0
     */
    file: string[];
    /**
     * The directory that holds this part.
     * @since 1.0.0
     */
    directory: string;
    /**
     * The name of this part
     * @since 1.0.0
     */
    name: string;
    /**
     * Whether this part is disabled or not
     * @since 1.0.0
     */
    disabled: boolean;
    /**
     * The full category of this part.
     * @since 1.0.0
     */
    fullCategory: string[];
    protected constructor(
      store: Store<Part>,
      directory: string,
      file: string[],
      options?: PartOptions
    );
    static set defaults(defaults: PartOptions);
    /**
     * The full path of this part
     * @since 1.0.0
     */
    get path(): string;
    /**
     * The category of this part.
     * @since 1.0.0
     */
    get category(): string;
    /**
     * A typescript helper decorator.
     * @param options The options to use when creating the part
     * @constructor
     */
    static Setup(
      options?: PartOptions
    ): <T extends new (...args: any[]) => Part>(t: T) => T;
    /**
     * Called once the bot is ready.
     */
    init(...args: any[]): void;
    /**
     * Reloads this piece.
     * @since 1.0.0
     */
    reload(): Promise<Part>;
    /**
     * Remove this piece from the store.
     * @since 1.0.0
     */
    unload(): Part | null;
    /**
     * Disables this part.
     * @since 1.0.0
     */
    disable(): this;
    /**
     * Enables this part.
     * @since 1.0.0
     */
    enable(): this;
  }

  type Channel = TextChannel | VoiceChannel;
  export class ClientUtil {
    resolveUser(
      text: string,
      users: Col<User>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): User | undefined;
    resolveUsers(
      text: string,
      users: Col<User>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): User[];
    checkUser(
      text: string,
      user: User,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): boolean;
    resolveMember(
      text: string,
      members: Col<Member>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Member | undefined;
    resolveMembers(
      text: string,
      members: Col<Member>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Member[];
    checkMember(
      text: string,
      member: Member,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): boolean;
    resolveChannel(
      text: string,
      channels: Col<any>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Channel | undefined;
    resolveChannels(
      text: string,
      channels: Col<any>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Channel[];
    checkChannel(
      text: string,
      channel: Channel,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): boolean;
    resolveRole(
      text: string,
      roles: Col<Role>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Role | undefined;
    resolveRoles(
      text: string,
      roles: Col<Role>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Role[];
    checkRole(
      text: string,
      role: Role,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): boolean;
    resolveEmoji(
      text: string,
      emojis: Emoji[],
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Emoji;
    resolveEmojis(
      text: string,
      emojis: Emoji[],
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Emoji[];
    checkEmoji(
      text: string,
      emoji: Emoji,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): boolean;
    resolveGuild(
      text: string,
      guilds: Col<Guild>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Guild | undefined;
    resolveGuilds(
      text: string,
      guilds: Col<Guild>,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): Guild[];
    checkGuild(
      text: string,
      guild: Guild,
      caseSensitive?: boolean,
      wholeWord?: boolean
    ): boolean;
    awaitMessages(
      channel: TextableChannel,
      options: MessageCollectorOptions
    ): Promise<Collection<string, Message>>;
  }
  export {};

  export type Parser = (...args: any[]) => any;
  export interface LanguageHelperOptions {
    createDirectory?: boolean;
    directory?: string;
    parse?: Parser;
    fallbackLang?: string;
  }
  export class LanguageHelper extends LiteEmitter {
    /**
     * The client that is using this store.
     * @since 1.0.5
     */
    readonly client: BladeClient;
    /**
     * All of the loaded languages.
     * @since 1.0.5
     */
    readonly storage: Collection<string, Language>;
    /**
     * The fallback language in case a language isn't found or a namespace isn't found.
     * @since 1.0.5
     */
    fallbackLang: string;
    /**
     * Whether to create the directory if none exists.
     * @since 1.0.5
     */
    createDirectory: boolean;
    /**
     * The directory to load from.
     * @since 1.0.5
     */
    directory: string;
    /**
     * The parser for metadata files.
     * @since 1.0.5
     */
    parse: Parser;
    /**
     * @param client
     * @param options
     */
    constructor(client: BladeClient, options?: LanguageHelperOptions);
    /**
     * Load all languages and their namespaces.
     * @since 1.0.5
     */
    loadAll(): Promise<void>;
    /**
     * Loads a namespace.
     * @param language The language that
     * @param file
     * @since 1.0.5
     */
    load(language: Language, file: string[]): Promise<void>;
    /**
     * Get a translation by it's path.
     * @since 1.0.5
     */
    translate<T = string>(
      lang: string,
      path: string,
      data?: Record<string, any>
    ): T;
  }

  export class Namespace {
    /**
     * This namespaces logger.
     * @since 1.0.5
     */
    readonly logger: Logger;
    /**
     * The blade client.
     * @since 1.0.5
     */
    readonly client: BladeClient;
    /**
     * The language this namespace belongs to.
     * @since 1.0.5
     */
    readonly language: Language;
    /**
     * The file array of this part.
     * @since 1.0.0
     */
    file: string[];
    /**
     * The directory that holds this part.
     * @since 1.0.0
     */
    directory: string;
    /**
     * THe name of this part
     * @since 1.0.0
     */
    name: string;
    constructor(
      language: Language,
      file: string[],
      options?: Omit<PartOptions, "category" | "disabled">
    );
    /**
     * The namespace data getter.
     */
    get data(): Record<string, any>;
    /**
     * A typescript helper decorator.
     * @param options The options to use when creating this listener.
     * @constructor
     */
    static Setup(
      options: PartOptions
    ): <T extends new (...args: any[]) => Part>(t: T) => T;
  }

  export type CooldownType = "author" | "channel";
  export type Restrictions = "owner" | "guildOwner";
  export type AllowedChannels = "text" | "dm";
  export type RegexProvider = (ctx: Context) => RegExp | Promise<RegExp>;
  export type Before = (ctx: Context) => boolean | Promise<boolean>;
  export type KeySupplier = (ctx: Context, args?: any) => string;
  export type ExecutionPredicate = (ctx: Context) => boolean;
  export type TFunction<T = string> = (
    path: string,
    data?: Record<string, any>
  ) => T;
  export type GetTranslation<T = string> = (t: TFunction<T>) => T;
  export interface CommandDescription {
    /**
     * The description content.
     */
    content?: string | GetTranslation;
    /**
     * Extended help for this command.
     */
    extendedContent?: string | GetTranslation;
    /**
     * How to use this command.
     */
    usage?: string | GetTranslation;
    /**
     * Examples of this command.
     */
    examples?: string[] | GetTranslation;
  }
  export interface CommandOptions extends PartOptions {
    /**
     * Command aliases to use.
     */
    aliases?: string[];
    /**
     * Description of the command.
     */
    description?: CommandDescription | GetTranslation<CommandDescription>;
    /**
     * The command arguments.
     */
    args?: ArgumentOptions[] | ArgumentGenerator;
    /**
     * Command Restrictions
     */
    restrictions?: Restrictions | Restrictions[];
    /**
     * Channel types that the command can be ran in.
     */
    channel?: AllowedChannels | AllowedChannels[];
    /**
     * Permissions needed by the invoker.
     */
    userPermissions?: Permission | Permission[];
    /**
     * Permissions needed by the client.
     */
    permissions?: Permission | Permission[];
    /**
     * Per-Command inhibitors to use.
     */
    inhibitors?: string | string[];
    /**
     * Whether this command is editable or not.
     */
    editable?: boolean;
    /**
     * The amount of times the command can be ran before being ratelimited.
     */
    bucket?: number;
    /**
     * The cooldown for this command.
     */
    cooldown?: number;
    /**
     * The cooldown type for this command.
     */
    cooldownType?: CooldownType;
    /**
     * Whether this command his hidden or not.
     */
    hidden?: boolean;
    /**
     * Whether this command is guarded or not.
     */
    guarded?: boolean;
    /**
     * User ID(s) or a function that will be ignored when checking permissions.
     */
    ignorePermissions?: string | string[] | IgnorePermissions;
    /**
     * User ID(s) or a function that will be ignored when checking cooldowns.
     */
    ignoreCooldown?: string | string[] | IgnoreCooldown;
    /**
     * Specific prefixes for this command.
     */
    prefixes?: string | string[] | PrefixProvider;
    /**
     * Default argument options for this command.
     */
    argumentDefaults?: DefaultArgumentOptions;
    /**
     * Use a regexp as a invoke.
     */
    regex?: RegExp | RegexProvider;
    /**
     * A method called before this command gets ran.
     */
    before?: Before;
    /**
     * A condition that allows this command to run.
     */
    condition?: ExecutionPredicate;
    flags?: string[];
    optionFlags?: string[];
    quoted?: boolean;
    separator?: string;
    lock?: "guild" | "channel" | "user" | KeySupplier;
  }
  /**
   * The base command class.
   * @since 1.0.0
   */
  export class Command extends Part {
    #private;
    readonly locker: Set<KeySupplier>;
    /**
     * The command store.
     * @since 1.0.0
     */
    readonly store: CommandStore;
    /**
     * The aliases for this command.
     */
    aliases: string[];
    /**
     * This commands description.
     * @since 1.0.0
     */
    description: CommandDescription | GetTranslation<CommandDescription>;
    /**
     * Restrictions for this command.
     * @since 1.0.0
     */
    restrictions: Restrictions[];
    /**
     * The channel types allowed to run this command.
     * @since 1.0.0
     */
    channel: AllowedChannels[];
    /**
     * Permissions the invoker needs to run this command.
     * @since 1.0.0
     */
    userPermissions: Permission[];
    /**
     * Permissions the bot needs before running this command.
     * @since 1.0.0
     */
    permissions: Permission[];
    /**
     * Per-command inhibitors to run.
     * @since 1.0.0
     */
    inhibitors: string[];
    /**
     * Whether this command can be edited or not.
     * @since 1.0.0
     */
    editable: boolean;
    /**
     * The amount of times the command can be ran before being ratelimited.
     * @since 1.0.0
     */
    bucket: number;
    /**
     * The cooldown for this command.
     * @since 1.0.0
     */
    cooldown: number;
    /**
     * The cooldown type for this command.
     * @since 1.0.0
     */
    cooldownType: CooldownType;
    /**
     * Whether this command his hidden or not.
     * @since 1.0.0
     */
    hidden: boolean;
    /**
     * Whether this command is guarded or not.
     * @since 1.0.0
     */
    guarded: boolean;
    /**
     * Specific prefixes for this command.
     * @since 1.0.0
     */
    prefix: string[] | PrefixProvider | null;
    /**
     * Default argument options for this command.
     * @since 1.0.0
     */
    argumentDefaults: DefaultArgumentOptions;
    /**
     * A method that gets called right before the command gets ran.
     * @since 1.0.0
     */
    before: Before;
    /**
     * A condition method that gets called before this command runs.
     * @since 1.0.0
     */
    condition: ExecutionPredicate;
    /**
     * Use a regexp as an invoke
     * @since 1.0.0
     */
    regex: RegExp | RegexProvider | null;
    lock: KeySupplier | null;
    /**
     * Creates a new Command.
     * @param store The command store.
     * @param dir The directory that holds this command/
     * @param file The path to this command.
     * @param options Options to use.
     */
    constructor(
      store: CommandStore,
      dir: string,
      file: string[],
      options?: CommandOptions
    );
    /**
     * Returns the bytecode of the required user permissions.
     * @since 1.0.0
     */
    get userPermissionsBytecode(): number;
    /**
     * Returns the bytecode of the required client permissions.
     * @since 1.0.0
     */
    get permissionsBytecode(): number;
    /**
     * A typescript helper decorator.
     * @param options The options to use when creating this command.
     * @constructor
     */
    static Setup(
      options?: CommandOptions
    ): <T extends new (...args: any[]) => Part>(t: T) => T;
    /**
     * Parses the arguments of this command.
     * @param message
     * @param content
     */
    parse(message: Message, content: string): Promise<any>;
  }

  export type IgnorePermissions = (
    message: Message,
    command: Command
  ) => boolean;
  export type IgnoreCooldown = (message: Message, command: Command) => boolean;
  export type PrefixProvider = (
    ctx: Context
  ) => string | string[] | Promise<string | string[]>;
  export type LanguageGetter = (ctx: Context) => string | Language;
  export interface HandlingOptions {
    /**
     * A method used for getting a language.
     */
    getLanguage?: LanguageGetter;
    /**
     * The prefixes to use.
     */
    prefix?: string | string[] | PrefixProvider;
    /**
     * Whether to handle command edits.
     */
    handleEdits?: boolean;
    /**
     * Whether you want the command handling enabled or not.
     */
    enabled?: boolean;
    /**
     * Whether to allow bot accounts to run commands.
     */
    allowBots?: boolean;
    /**
     * Whether to allow the client to run commands.
     */
    allowSelf?: boolean;
    /**
     * Whether to allow users to run commands.
     */
    allowUsers?: boolean;
    /**
     * ID of user(s) to ignore `userPermissions` checks or a function to ignore.
     */
    ignorePermissions?: string | string[] | IgnorePermissions;
    aliasReplacement?: RegExp;
    /**
     * ID of user(s) to ignore cooldown or a function to ignore.
     */
    ignoreCooldown?: string | string[] | IgnoreCooldown;
    /**
     * Whether to store messages.
     */
    storeMessages?: boolean;
    /**
     * Whether to send a typing indicator.
     */
    sendTyping?: boolean;
    /**
     * Default options for arguments.
     */
    argumentDefaults?: DefaultArgumentOptions;
  }
  export interface CommandStoreOptions extends StoreOptions {
    /**
     * Message handling options.
     */
    handling?: HandlingOptions;
    /**
     * The default command cooldown.
     */
    defaultCooldown?: number;
  }
  /**
   * A command store that handles loading of commands.
   */
  export class CommandStore extends Store<Command> {
    readonly types: TypeResolver;
    /**
     * The inhibitor store to use while handling messages.
     * @since 1.0.0
     */
    inhibitors?: InhibitorStore;
    /**
     * Settings to use while handling
     * @since 1.0.0
     */
    handling: HandlingOptions;
    /**
     * The default command cooldown.
     * @since 1.0.0
     * @default 5 seconds
     */
    defaultCooldown: number;
    /**
     * An alias storage.
     * @since 1.0.0
     */
    aliases: Collection<string, string>;
    /**
     * A prefix storage.
     */
    prefixes: Collection<string | PrefixProvider, Set<string>>;
    /**
     * Creates a new Command Store
     * @param client The client that is using this command store.
     * @param options The options to give.
     */
    constructor(client: BladeClient, options?: CommandStoreOptions);
    /**
     * A wrapper for the super.add method
     * @param part
     * @since 1.0.0
     */
    add(part: Command): Command | null;
    /**
     * A wrapper for the super.remove method.
     * @param resolvable
     * @since 1.0.0
     */
    remove(resolvable: ComponentResolvable<Command>): Command | null;
    useInhibitorStore(inhibitorStore: InhibitorStore): this;
    useMonitorStore(inhibitorStore: MonitorStore): this;
    useListenersStore(listenerStore: SubscriberStore): this;
    /**
     * Finds a command
     * @param id
     */
    findCommand(id: string): Command | undefined;
    /**
     * Handles a sent message.
     * @param message The received message.
     * @since 1.0.0
     */
    handle(message: Message): Promise<boolean>;
    handleRegexAndConditionalCommands(message: Message): Promise<boolean>;
    handleRegexCommands(message: Message): Promise<boolean>;
    handleConditionalCommands(message: Message): Promise<boolean>;
    handleDirectCommand(
      message: Message,
      content: string,
      command: Command,
      ignore?: boolean
    ): Promise<null | void | boolean>;
    runCommand(
      message: Message,
      command: Command,
      args: Record<string, any>
    ): Promise<void>;
    parseCommand(message: Message): Promise<ContextData>;
    parseMultiplePrefixes(
      message: Message,
      pairs: [string, Set<string> | null][]
    ): ContextData;
    parseWithPrefix(
      message: Message,
      prefix: string,
      associatedCommands?: Set<string> | null
    ): ContextData;
    parseCommandOverwrittenPrefixes(message: Message): Promise<ContextData>;
    /**
     * Runs all "all" type inhibitors.
     * @param message The message to pass.
     * @since 1.0.0
     */
    runAllTypeInhibitors(message: Message): Promise<boolean>;
    /**
     * Runs all "pre" type inhibitors
     * @param message The message to pass.
     * @since 1.0.0
     */
    runPreTypeInhibitors(message: Message): Promise<boolean>;
    /**
     * Runs all "post" type inhibitors.
     * @param message The message to pass.
     * @param command The command to pass.
     * @since 1.0.0
     */
    runPostTypeInhibitors(message: Message, command: Command): Promise<boolean>;
    runAllCommandInhibitors(
      message: Message,
      command: Command
    ): Promise<boolean>;
    /**
     * Runs permissions checks.
     * @param message The message to pass.
     * @param command THe command to pass.
     */
    runPermissionChecks(message: Message, command: Command): Promise<boolean>;
    /**
     * Add a prompt to the prompt storage.
     * @param channel The channel of the prompt.
     * @param user The user to add.
     */
    addPrompt(channel: Channel, user: User): void;
    /**
     * Removes a prompt
     * @param channel Prompt channel.
     * @param user Prompt user.
     */
    removePrompt(channel: Channel, user: User): void;
    /**
     * Check if a prompt exists.
     * @param channel The channel of the prompt.
     * @param user A user of the prompt.
     */
    hasPrompt(channel: Channel, user: User): boolean;
  }
  export enum CommandStoreEvents {
    MESSAGE_INHIBITED = "messageInhibited",
    MESSAGE_INVALID = "messageInvalid",
    IN_PROMPT = "messageInPrompt",
    MISSING_PERMISSIONS = "missingPermissions",
    COMMAND_INHIBITED = "commandInhibited",
    COMMAND_BREAKOUT = "commandBreakout",
    COMMAND_LOCKED = "commandLocked",
    COMMAND_CANCELLED = "commandCancelled",
    COMMAND_STARTED = "commandStarted",
    COMMAND_FINISHED = "commandFinished",
  }
  export enum PreDefinedReason {
    SELF = "blockedSelf",
    BOT = "blockedBot",
    GUILD = "guild",
    DM = "dm",
    DEVELOPER = "developer",
  }

  export type Constructor<T = unknown> = new (...args: readonly unknown[]) => T;
  export interface ExtendableOptions extends PartOptions {
    appliesTo?: readonly Constructor[];
  }
  export interface OriginalPropertyDescriptors {
    staticPropertyDescriptors: Record<string, PropertyDescriptor>;
    instancePropertyDescriptors: Record<string, PropertyDescriptor>;
  }
  export class Extendable extends Part {
    constructor(
      store: ExtendableStore,
      dir: string,
      file: string[],
      options?: ExtendableOptions
    );
    init(): void;
    /**
     * Disables this piece
     * @since 0.0.1
     */
    disable(): this;
    /**
     * Enables this Component
     * @since 0.0.1
     */
    enable(init?: boolean): this;
  }

  export class ExtendableStore extends Store<Extendable> {
    constructor(client: BladeClient, options?: StoreOptions);
    /**
     * Removes an extendable from the store.
     * @param extendable The extendable to remove
     * @since 1.0.6
     */
    remove(extendable: ComponentResolvable<Extendable>): Extendable | null;
    /**
     * Adds an extendable to this store.
     * @param extendable The extendable to add.
     * @since 1.0.6
     */
    add(extendable: Extendable): Extendable | null;
  }

  export type InhibitorType = "all" | "pre" | "post" | "command";
  export interface InhibitorOptions extends PartOptions {
    /**
     * The type of inhibitor.
     * Can be 'all' to run on all messages, 'pre' to run on messages not blocked by the built-in inhibitors, or 'post' to run on messages that are commands, or 'command' to be ran on certain commands.
     */
    type?: InhibitorType;
    /**
     * Reason emitted when command or message is blocked.
     * @default Inhibitor Name.
     */
    reason?: string;
    /**
     * Priority for the inhibitor for when more than one inhibitors block a message.
     */
    priority?: number;
  }
  /**
   * A message inhibitor.
   * @since 1.0.0
   */
  export class Inhibitor extends Part {
    /**
     * The type of inhibitor.
     * @since 1.0.0
     */
    type: InhibitorType;
    /**
     * Reason emitted when command or message is blocked.
     * @since 1.0.0
     */
    reason: string;
    /**
     * Priority for the inhibitor for when more than one inhibitors block a message.
     * @since 1.0.0
     */
    priority: number;
    /**
     * Creates a new Inhibitor.
     * @param store The store this inhibitor belongs to
     * @param dir The directory this inhibitor is in.
     * @param path The file path this inhibitor.
     * @param options The options to give this inhibitor.
     */
    constructor(
      store: InhibitorStore,
      dir: string,
      path: string[],
      options?: InhibitorOptions
    );
    run(...args: any[]): boolean | Promise<boolean>;
  }

  export class InhibitorStore extends Store<Inhibitor> {
    constructor(client: BladeClient, options?: StoreOptions);
    /**
     * Tests inhibitors against the message.
     * @param type The type of inhibitors to test.
     * @param message Message to test.
     * @param command Command to use.
     */
    test(
      type: InhibitorType,
      message: Message,
      command?: Command
    ): Promise<string | null>;
  }

  export type Emitter = EventEmitter | LiteEmitter;
  type Fn = (...args: any[]) => any;
  type Mode = "once" | "on";
  type Mappings = Record<string, Fn | string | Subscription>;
  export interface SubscriberOptions extends PartOptions {
    /**
     * The event to listen for.
     */
    event: string | string[];
    /**
     * The emitter to attach the listener to.
     */
    emitter?: string | Emitter;
    /**
     * Event mappings for use with multiple events.
     */
    mappings?: Record<string, Subscription>;
    /**
     * The listener mode.
     */
    mode?: Mode;
  }
  export interface Subscription {
    event: string;
    fn?: (...args: any) => any;
    emitter?: string | Emitter;
    mode?: Mode;
  }
  /**
   * An abstract class for adding a listener to an emitter.
   * @since 1.0.0
   * @extends Part
   */
  export class Subscriber extends Part {
    /**
     * The store this listener belongs to.
     */
    readonly store: SubscriberStore;
    /**
     * The event or events to listen for.
     */
    event: string | string[];
    /**
     * The emitter to attach the listener to
     * @since 1.0.0
     */
    emitter: Emitter;
    /**
     * Event mappings for use with multiple events.
     * @since 1.0.0
     */
    mappings: Mappings;
    /**
     * The mode of the listener, "on" | "off" | "once"
     * @since 1.0.0
     */
    mode: Mode;
    constructor(
      store: SubscriberStore,
      dir: string,
      file: string[],
      options: SubscriberOptions
    );
    /**
     * A typescript helper decorator.
     * @param options The options to use when creating this listener.
     * @constructor
     */
    static Setup(
      options: SubscriberOptions
    ): <T extends new (...args: any[]) => Part>(t: T) => T;
    run(...args: any[]): any | Promise<any>;
    /**
     * Attaches the proper listener to the emitter
     * @since 1.0.0
     * @private
     */
    _listen(this: Subscriber): void;
    /**
     * Removes the listener from the emitter
     * @since 0.0.0-alpha
     * @private
     */
    _unListen(): void;
  }
  export {};

  export interface SubscriberStoreOptions extends StoreOptions {
    emitters?: Record<string, Emitter>;
  }
  export class SubscriberStore extends Store<Subscriber> {
    emitters: Record<string, Emitter>;
    constructor(client: BladeClient, options?: SubscriberStoreOptions);
    /**
     * A wrapper for the super.remove method.
     * @param resolvable The listener to remove.
     */
    remove(resolvable: ComponentResolvable<Subscriber>): Subscriber | null;
    /**
     * A wrapper for the super.add method.
     * @param part The listener to add.
     */
    add(part: Subscriber): Subscriber | null;
  }

  export class Monitor extends Part {
    /**
     * The monitor store that stores this part.
     * @since 1.0.0
     */
    readonly store: MonitorStore;
    /**
     * A typescript helper decorator.
     * @param options The options to use when creating this listener.
     * @constructor
     */
    static Setup(
      options: PartOptions
    ): <T extends new (...args: any[]) => Part>(t: T) => T;
    /**
     * Runs this monitor
     * @param message
     */
    run(message: Message): Promise<void>;
    _ran(message: Message): Promise<void>;
  }

  /**
   * A monitor store that handles loading of monitors.
   */
  export class MonitorStore extends Store<Monitor> {
    /**
     * The emitter that contains all of the monitor runners.
     * @since 1.0.0
     */
    emitter: LiteEmitter;
    /**
     * Creates a new Monitor Store
     * @param client The client that is using this command store.
     * @param options The options to give.
     */
    constructor(client: BladeClient, options?: StoreOptions);
    /**
     * A wrapper for the super.remove method.
     * @param resolvable
     * @since 1.0.0
     */
    remove(resolvable: ComponentResolvable<Monitor>): Monitor | null;
    /**
     * A wrapper for the super.add method.
     * @param part
     * @since 1.0.0
     */
    add(part: Monitor): Monitor | null;
  }

  export abstract class Provider<V extends any> {
    protected storage: Collection<string, V>;
    abstract init(): Promise<any>;
    abstract get<T>(id: string, path?: string): T | Provider<T>;
    abstract delete(id: string, path?: string): any | Promise<any>;
    abstract update(id: string, value: any, path?: string): any | Promise<any>;
  }

  export interface Metadata {
    author?: string | string[];
    alias?: string | string[];
    id?: string;
  }
  export class Language {
    /**
     * The helper that loaded this language.
     * @since 1.0.5
     */
    readonly helper: LanguageHelper;
    /**
     * The folder that belongs to this language.
     * @since 1.0.5
     */
    readonly folder: string;
    /**
     * The different aliases for this language.
     * @since 1.0.5
     */
    aliases: string[];
    /**
     * The author(s) that created this language.
     * @since 1.0.5
     */
    authors: string[];
    /**
     * The id of this language.
     * @since 1.0.5
     */
    id: string;
    /**
     * @param helper
     * @param folder
     * @param metadata
     */
    constructor(
      helper: LanguageHelper,
      folder: string,
      { id: _id, author, alias }?: Metadata
    );
    /**
     * Add a namespace to the map of namespaces.
     * @param ns The namespace to set.
     * @since 1.0.5
     */
    addNamespace(ns: Namespace): Map<string, Namespace>;
    /**
     * Get a namespace by it's name.
     * @param ns The namespace to get.
     * @since 1.0.5
     */
    getNamespace(ns: string): Namespace | undefined;
    /**
     * Get a translation.
     * @param path The path to the translation.
     * @param data Data to use.
     */
    translate(path: string, data?: Record<string, any>): any;
  }

  export type MessageIteratorOptions = EventIteratorOptions<[Message]>;
  /**
   * An asynchronous iterator responsible for iterating over messages.
   * @since 1.0.0
   */
  export class MessageIterator extends EventIterator<[Message]> {
    /**
     * Construct's a new MessageIterator.
     * @param channel The channel to listen for messages.
     * @param options Any additional options to pass.
     * @since 1.0.0
     */
    constructor(
      channel: TextableChannel | PrivateChannel,
      options?: MessageIteratorOptions
    );
  }

  /**
   * The base structure collector for asynchronously collecting values.
   * @since 0.0.1
   */
  export class Collector<
    T extends Base,
    R extends [T, ...unknown[]],
    I extends EventIterator<R>
  > {
    #private;
    /**
     * The collected values.
     * @since 0.0.1
     */
    protected collected: Collection<string, T>;
    /**
     * Creates a new Collector.
     * @param iterator The EventIterator that is yielding values.
     * @since 1.0.0
     */
    constructor(iterator: I);
    /**
     * Collect's the values into the Collector's cache.
     * @since 1.0.0
     */
    collect(): Promise<Collection<string, T>>;
  }

  export interface Embed {
    title?: string;
    description?: string;
    image?: EmbedImage;
    author?: EmbedAuthor;
    thumbnail?: EmbedThumbnail;
    fields?: EmbedField[];
    timestamp?: Date;
    footer?: EmbedFooter;
    color?: number;
    type?: "rich";
    url?: string;
  }
  export interface EmbedAuthor {
    name: string;
    url?: string;
    icon_url?: string;
  }
  export interface EmbedThumbnail {
    url?: string;
  }
  export interface EmbedImage {
    url?: string;
  }
  export interface EmbedField {
    name: string;
    value: string;
    inline?: boolean;
  }
  export interface EmbedFooter {
    text: string;
    icon_url?: string;
  }
  export class EmbedBuilder {
    constructor(data?: Embed);
    static get default(): EmbedBuilder;
    color(color: number): EmbedBuilder;
    title(title: string): EmbedBuilder;
    description(text: string): EmbedBuilder;
    author(name: string, url?: string, iconURL?: string): EmbedBuilder;
    thumbnail(url: string): EmbedBuilder;
    field(name: string, value: string, inline?: boolean): EmbedBuilder;
    image(url: string): EmbedBuilder;
    timestamp(t?: Date): EmbedBuilder;
    footer(txt: string, iconURL?: string): EmbedBuilder;
    url(url: string): EmbedBuilder;
    build(): EmbedOptions;
  }

  /**
   * Options for a MessageCollector.
   * @since 0.0.1
   */
  export interface MessageCollectorOptions {
    /**
     * The amount of messages to collect before ending the collector.
     * @since 0.0.1
     */
    limit?: number;
    /**
     * The time in ms that a MessageCollector will go before idling out.
     * @since 0.0.1
     */
    idle?: number;
    /**
     * The filter used to filter out specific messages.
     * @since 0.0.1
     */
    filter?: (
      message: [Message],
      collected: Collection<string, Message>
    ) => boolean;
  }
  /**
   * The MessageCollector class responsible for collecting a set of messages.
   * @since 0.0.1
   */
  export class MessageCollector extends Collector<
    Message,
    [Message],
    MessageIterator
  > {
    /**
     * Construct's a new MessageCollector.
     * @since 0.0.1
     * @param channel The channel to listen for messages.
     * @param options Any additional options to pass.
     */
    constructor(
      channel: TextableChannel | PrivateChannel,
      options: MessageCollectorOptions
    );
  }

  /**
   * Credit goes to: https://github.com/NinoDiscord/Nino/blob/edge/src/util/PermissionUtils.ts
   */
  /**
   * Contains utility functions to help with permission checking and hierarchy.
   * @since 1.0.0
   */
  export class Permissions {
    /**
     * Returns the highest role the member has
     * undefined if the member doesn't have a role
     * @param member the member
     */
    static topRole(member: Member): Role | undefined;
    /**
     * Returns true if a is above b in the hierarchy, otherwise false.
     */
    static above(a: Member, b: Member): boolean;
    /**
     * Calculates permissions of a role in a channel.
     * @param role The role to calculate the permissions of.
     * @param channel The channel to use.
     * @since 1.0.0
     */
    static permissionsOf(role: Role, channel: GuildChannel): number;
    /**
     * Shows a string representation of all of the permissions
     * @param permission The permissions bit-field.
     * @since 1.0.0
     */
    static toString(permission: number): string;
    /**
     * Returns whether the permission the user has overlap the permissions required
     * @param user The permission the user has
     * @param required The permissions required
     * @since 1.0.0
     */
    static overlaps(user: number, required: number): boolean;
    static add(...a: number[]): number;
  }

  /**
   * A ratelimit class.
   * @since 1.0.0
   */
  export class Ratelimit {
    /**
     * The number of requests before this is limited
     * @since 1.0.0
     */
    bucket: number;
    /**
     * The amount of milliseconds for the ratelimit to expire
     * @since 1.0.0
     */
    cooldown: number;
    /**
     * @param bucket The number of requests before this is limited
     * @param cooldown The amount of milliseconds for this ratelimit to expire
     * @since 1.0.0
     */
    constructor(bucket: number, cooldown: number);
    /**
     * Whether this RateLimit is expired or not, allowing the bucket to be reset
     */
    get expired(): boolean;
    /**
     * Whether this RateLimit is limited or not
     */
    get limited(): boolean;
    /**
     * The remaining time in milliseconds before this RateLimit instance is reset
     */
    get remainingTime(): number;
    /**
     * Drips the RateLimit bucket
     * @since 1.0.0
     */
    drip(): this;
    /**
     * Resets the RateLimit back to it's full state
     * @since 1.0.0
     */
    reset(): this;
    /**
     * Resets the RateLimit's remaining uses back to full state
     * @since 1.0.0
     */
    resetRemaining(): this;
    /**
     * Resets the RateLimit's reset time back to full state
     * @since 1.0.0
     */
    resetTime(): this;
  }

  export class RatelimitManager<K = string> extends Collection<K, Ratelimit> {
    /**
     * @param bucket The amount of times a RateLimit can drip before it's limited
     * @param cooldown The amount of milliseconds for the ratelimits from this manager to expire
     */
    constructor(bucket: number, cooldown: number);
    static get [Symbol.species](): typeof Collection;
    /**
     * The amount of times a RateLimit from this manager can drip before it's limited
     * @since 1.0.0
     */
    get bucket(): number;
    /**
     * @since 1.0.0
     * @param value
     */
    set bucket(value: number);
    /**
     * The amount of milliseconds for the ratelimits from this manager to expire
     * @since 1.0.0
     */
    get cooldown(): number;
    /**
     * @since 1.0.0
     * @param value
     */
    set cooldown(value: number);
    /**
     * Gets a RateLimit from this manager or creates it if it does not exist
     * @param id The id for the RateLimit
     * @since 1.0.0
     */
    acquire(id: K): Ratelimit;
    /**
     * Creates a RateLimit for this manager
     * @param id The id the RateLimit belongs to
     * @since 1.0.0
     */
    create(id: K): Ratelimit;
    /**
     * Wraps Collection's set method to set interval to sweep inactive RateLimits
     * @param id The id the RateLimit belongs to
     * @param ratelimit The RateLimit to set
     * @since 1.0.0
     */
    set(id: K, ratelimit: Ratelimit): this;
    /**
     * Wraps Collection's sweep method to clear the interval when this manager is empty
     * @param fn The filter function
     * @param thisArg The this for the sweep
     * @since 1.0.0
     */
    sweep(
      fn?: (value: Ratelimit, key: K, collection: this) => boolean,
      thisArg?: any
    ): number;
  }

  export enum ArgumentMatches {
    PHRASE = "phrase",
    FLAG = "flag",
    OPTION = "option",
    REST = "rest",
    SEPARATE = "separate",
    TEXT = "text",
    CONTENT = "content",
    REST_CONTENT = "restContent",
    NONE = "none",
  }
  export enum ArgumentTypes {
    STRING = "string",
    LOWERCASE = "lowercase",
    UPPERCASE = "uppercase",
    CHAR_CODES = "charCodes",
    NUMBER = "number",
    INTEGER = "integer",
    BIGINT = "bigint",
    EMOJINT = "emojint",
    URL = "url",
    DATE = "date",
    COLOR = "color",
    USER = "user",
    USERS = "users",
    MEMBER = "member",
    MEMBERS = "members",
    CHANNEL = "channel",
    CHANNELS = "channels",
    TEXT_CHANNEL = "textChannel",
    TEXT_CHANNELS = "textChannels",
    VOICE_CHANNEL = "voiceChannel",
    VOICE_CHANNELS = "voiceChannels",
    CATEGORY_CHANNEL = "categoryChannel",
    CATEGORY_CHANNELS = "categoryChannels",
    NEWS_CHANNEL = "newsChannel",
    NEWS_CHANNELS = "newsChannels",
    STORE_CHANNEL = "storeChannel",
    STORE_CHANNELS = "storeChannels",
    ROLE = "role",
    ROLES = "roles",
    EMOJI = "emoji",
    EMOJIS = "emojis",
    GUILD = "guild",
    GUILDS = "guilds",
    MESSAGE = "message",
    GUILD_MESSAGE = "guildMessage",
    RELEVANT_MESSAGE = "relevantMessage",
    INVITE = "invite",
    USER_MENTION = "userMention",
    MEMBER_MENTION = "memberMention",
    CHANNEL_MENTION = "channelMention",
    ROLE_MENTION = "roleMention",
    EMOJI_MENTION = "emojiMention",
    COMMAND_ALIAS = "commandAlias",
    COMMAND = "command",
    INHIBITOR = "inhibitor",
    LISTENER = "listener",
  }

  type LiteEmitterHandler = (...args: Array<any>) => void;
  /**
   * An error that's created whenever a handler has throw an error.
   */
  export class LiteEmitterError extends GenericError {}
  /**
   * A simplified EventEmitter.
   * @since 1.0.0
   */
  export class LiteEmitter {
    /**
     * The amount of handlers for a given event.
     * @param event The event to get.
     * @since 1.0.0
     */
    handlerCount(event: string): number;
    /**
     * Add a handler function for a given event.
     * @param event The name of the event.
     * @param fn The handler function.
     */
    addListener(event: string, fn: LiteEmitterHandler): this;
    /**
     * Remove one or all handler functions for a given event.
     * @param event The name of the event.
     * @param fn Optional handler to detach.
     */
    removeListener(event: string, fn?: LiteEmitterHandler): this;
    /**
     * Add a handler function for a given event.
     * @param event The name of the event.
     * @param callback
     */
    on(event: string, callback: LiteEmitterHandler): this;
    /**
     * Add a handler function for a given event.
     * @param event The name of the event.
     * @param callback
     */
    once(event: string, callback: LiteEmitterHandler): this;
    /**
     * Emit a new event to handlers.
     * @param event The name of the event.
     * @param args Event arguments.
     */
    emit(event: string, ...args: Array<any>): this;
  }
  export {};

  /**
   * A storage structure.
   * @since 1.0.0
   */
  export class Collection<K, V> extends Map<K, V> {
    /**
     * The first item in this Storage
     */
    get first(): [K, V] | null;
    /**
     * The first value of this Storage
     */
    get firstValue(): V | null;
    /**
     * The first key of this Storage
     */
    get firstKey(): K | null;
    /**
     * The last item in this Storage
     */
    get last(): [K, V] | null;
    /**
     * The last value of this Storage
     */
    get lastValue(): V | null;
    /**
     * The last key of this Storage
     */
    get lastKey(): K | null;
    /**
     * Finds an entry from this Storage
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    find(
      fn: (value: V, key?: K, map?: this) => boolean,
      thisArg?: any
    ): V | undefined;
    /**
     * Finds a key from this Storage
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    findKey(
      fn: (value: V, key: K, map: this) => boolean,
      thisArg?: any
    ): K | undefined;
    /**
     * Finds a value from this Storage
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    findValue(
      fn: (value: V, key: K, map: this) => boolean,
      thisArg?: any
    ): V | undefined;
    /**
     * Sweeps entries from this Storage
     * @param fn Function used to determine what entries are swept
     * @param thisArg Optional binding for the fn param
     */
    sweep(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): number;
    /**
     * Returns a new filtered Storage based on the filter function
     * @param fn Function used to determine what entries are in the new Storage
     * @param thisArg Optional binding for the fn param
     */
    filter(
      fn: (value: V, key: K, map: this) => boolean,
      thisArg?: any
    ): Collection<K, V>;
    /**
     * Maps this Storage to an array (like Array#map())
     * @param fn Function to determine what is mapped to the new Array
     * @param thisArg Optional binding for the fn param
     */
    map<T = any>(fn: (value: V, key: K, map: this) => T, thisArg?: any): T[];
    /**
     * Tests if some entries in this Storage meets a condition
     * @param fn The function to test the condition
     * @param thisArg Optional binding for the fn param
     */
    some(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): boolean;
    /**
     * Tests if every entry in this Storage meets a condition
     * @param fn The function to test the condition
     * @param thisArg Optional binding for the fn param
     */
    every(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): boolean;
    /**
     * Reduces this Storage into a singularity
     * @param fn The function to determine how this Storage is reduced
     * @param initialValue The initial value
     * @param thisArg Optional binding for the fn param
     */
    reduce<I>(
      fn: (accumulator: I, value: V, key: K, map: this) => I,
      initialValue: I,
      thisArg?: any
    ): I;
    /**
     * Returns a shallow clone of this Storage
     */
    clone(): Collection<K, V>;
    /**
     * Returns a new Storage with this and other Storages together
     * @param Storages Other Storages to include in the new Storage
     */
    concat(...Storages: Collection<K, V>[]): Collection<K, V>;
    /**
     * Naive equality compare function
     * @param Storage The Storage to compare this against
     */
    equals(Storage: Collection<K, V>): boolean;
    /**
     * Sorts entries in-place in this Storage
     * @param compareFunction Function to determine how this Storage should be sorted
     */
    sort(compareFunction?: (v0: V, v1: V, k0?: K, k1?: K) => number): this;
    /**
     * Sorts entries in a new Storage
     * @param compareFunction Function to determine how the resulting Storage should be sorted
     */
    sorted(
      compareFunction?: (v0: V, v1: V, k0?: K, k1?: K) => number
    ): Collection<K, V>;
  }

  export abstract class Util {
    static array<T>(v: T | T[]): T[];
    static isFunction(i: any): i is Function;
    static isClass(input: unknown): boolean;
    static isObject(value: any): boolean;
    static getPathSegments(path: string): string[];
    static walk(directory: string, files?: string[]): string[];
    static deepAssign<T>(o1: any, ...os: any[]): T;
    static flatMap(xs: any[], f: Function): any[];
    static intoCallable(thing: any): (...args: any[]) => any;
    static isPromise(value: any): value is Promise<any>;
    static prefixCompare(
      aKey: string | Function,
      bKey: string | Function
    ): number;
    static choice<T>(...xs: T[]): T | null;
  }
}

export = Blade;
